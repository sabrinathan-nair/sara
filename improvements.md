# Project Improvements

This document lists identified areas for improvement in the Sara project, ordered from easiest to hardest to fix.

| Issue | Files affected | Issue code | Proposed solution | Proposed solution code |
|---|---|---|---|---|
| Redundant import of `fromJust` | `src/Sara/DataFrame/Wrangling.hs` | `import Data.Maybe (isNothing, fromJust, mapMaybe)` | Remove `fromJust` from import list. | `import Data.Maybe (isNothing, mapMaybe)` |
| `error` usage in test/benchmark files | `test/TestSuite.hs`, `test/Benchmark.hs` | `error ("Test failed: " ++ show e)` | Replace `error` with `throwIO` or `fail` in `IO` contexts, or use `QuickCheck`'s `counterexample` for properties. | `throwIO (userError ("Test failed: " ++ show e))` |
| Orphan `FromField` instances | `src/Sara/DataFrame/CsvInstances.hs` | `instance C.FromField Bool where ...` | Relocate instances to a more appropriate module (e.g., `Sara.DataFrame.IO` or a dedicated `Sara.DataFrame.CsvParsing`). | (Relocation, no direct code change here) |
| Duplicate `transpose` function | `src/Sara/DataFrame/SQL.hs` | `transpose :: [[a]] -> [[a]] ...` | Remove local `transpose` and import from `Sara.DataFrame.Internal.hs`. | (Removal, import statement) |
| `V.!` (partial indexing) in `inferCsvSchema` | `src/Sara/DataFrame/Static.hs` | `(row V.! colIdx)` | Replace `V.!` with `V.!?` (safe indexing) and handle `Nothing` case with a compile-time error. | `case row V.!? colIdx of Just val -> ... Nothing -> fail "Index out of bounds"` |
| `Map.findWithDefault NA` in `fromRows` | `src/Sara/DataFrame/Types.hs` | `colValues = V.fromList $ map (ow -> Map.findWithDefault NA colName row) rows` | Refactor `fromRows` to return `Either SaraError (DataFrame cols)` and propagate `ColumnNotFound` error if a column is missing. | (Requires significant refactoring, see previous attempts) |
| `Map.findWithDefault NA` in `melt` | `src/Sara/DataFrame/Transform.hs` | `cols' = [ V.fromList [ Map.findWithDefault NA colName r | r <- meltedRows ]` | Refactor `melt` to return `Either SaraError (DataFrame newCols)` and propagate `ColumnNotFound` error. | (Requires significant refactoring) |
| `Map.findWithDefault NA` in `sortDataFrame` | `src/Sara/DataFrame/Wrangling.hs` | `val1 = Map.findWithDefault NA colName r1` | Refactor `sortDataFrame` to return `Either SaraError (DataFrame cols)` and propagate `ColumnNotFound` error. | (Requires significant refactoring, see previous attempts) |
| `applyColumn` silently yields empty DataFrame on error | `src/Sara/DataFrame/Transform.hs` | `Nothing -> fromRows [] -- Yield empty DataFrame on error` | Propagate `SaraError` in the stream (e.g., `S.yield (Left (ColumnNotFound colName))`). | `Nothing -> S.yield (Left (ColumnNotFound colName))` |
| `filterRows` streaming inefficiency | `src/Sara/DataFrame/Transform.hs` | `let rows = toRows df ... return $ fromRows filteredRows` | Optimize `filterRows` to operate directly on `Vector`s within the `DataFrame` to avoid `toRows`/`fromRows` conversions. | (Requires significant refactoring) |
| `readCsv` (in `Sara.DataFrame.Static`) unimplemented | `src/Sara/DataFrame/Static.hs` | `readCsv filePath = return $ Left [ParsingError (T.pack "Not implemented")]` | Implement the function to read CSV into `V.Vector a` using `FromNamedRecord`. | (Requires implementation) |
| `validateEmployee` input type safety | `src/Sara/Validation/Employee.hs` | `validateEmployee :: (Int, Text, Text, Double, Day, Text) -> ...` | Use a record type or `Map` (like `Row`) as input to `validateEmployee` for better type safety. | (Requires refactoring input type) |
| Basic email validation in `mkEmail` | `src/Sara/Core/Types.hs` | `mkEmail email | '@' `T.elem` email = ...` | Implement more robust email validation (e.g., using a dedicated library or more comprehensive regex). | (Requires more complex validation logic) |
| `transpose` efficiency in `Internal.hs` | `src/Sara/DataFrame/Internal.hs` | `transpose :: [[a]] -> [[a]] ...` | Optimize `transpose` for large lists, potentially using `Vector` operations or a more efficient list-based algorithm. | (Requires more efficient algorithm) |
| Streaming Library Integration (General) | `src/Sara/DataFrame/IO.hs`, `src/Sara/DataFrame/Transform.hs`, etc. | (Various functions using `S.toList_`, `toRows`/`fromRows` in streaming contexts) | Fully leverage `Streaming` to avoid reading entire files into memory or converting DataFrames to lists unnecessarily. | (Architectural change, impacts many functions) |
| Type-Level Schema Enforcement (General) | `src/Sara/DataFrame.Types.hs`, `src/Sara.DataFrame.Static.hs`, etc. | (Implicit inconsistencies between type-level schema and runtime data) | Ensure runtime data consistency with type-level schema, potentially requiring changes to `DataFrame` internal representation or more rigorous validation at data ingestion points. | (Architectural change, impacts core data structures) |
| Type Inference Robustness | `src/Sara/DataFrame/Static.hs` | `inferDFType :: T.Text -> Q Language.Haskell.TH.Type` | Sample more rows (e.g., first N rows) or the entire column to infer the most general type for `inferDFType` and `inferColumnTypeFromSamples`. | (Requires changes to type inference logic) |
