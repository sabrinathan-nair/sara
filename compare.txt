# Feature-wise Comparison: Sara vs. Frames

This document provides a feature-wise comparison between the `sara` library (as developed in this session, with static typing capabilities) and the `Frames` library, both designed for data manipulation in Haskell.

| Feature             | Sara (with Static Typing)                                  | Frames                                                              |
| :------------------ | :--------------------------------------------------------- | :------------------------------------------------------------------ |
| **Core Philosophy** | Pandas-like API, with added static typing for robustness.  | Type-safe, efficient tabular data manipulation. Focus on compile-time guarantees. |
| **Typing**          | **Static** (via Template Haskell for CSV schema inference) | **Static** (via Template Haskell for CSV schema inference)          |
| **API Style**       | Pandas-like (e.g., `filterRows`, `selectColumns`)          | Lens-based for field access, `foldl` for aggregations.              |
| **Data I/O**        | CSV (with automatic type inference and static type generation) | CSV (with automatic type inference and static type generation), PostgreSQL (with `Frames-beam`) |
| **Data Wrangling**  | Extensive: Filtering, selecting, adding/mutating columns, joining, aggregation. | Extensive: Filtering, selecting, mutating, aggregating.             |
| **Joining**         | Yes (Left, Right, Inner, Outer joins)                      | Yes                                                                 |
| **Aggregation**     | Yes (group by, sum, mean, std, etc.)                       | Yes (leveraging `foldl` for efficient streaming aggregations)       |
| **Time Series**     | Yes (resampling, shifting, percentage change, rolling apply) | Not explicitly built-in as a core feature, but can be implemented using other libraries. |
| **Missing Data**    | Yes (fillna, ffill, bfill, dropna, isna, notna)             | Not explicitly built-in as core functions, but can be handled.      |
| **Statistical Functions** | Comprehensive set (sum, mean, std, min, max, count, median, mode, variance, skew, kurtosis) | Basic statistics available through `foldl` and other numeric libraries. |
| **String Operations** | Yes (lower, upper, strip, contains, replace)               | Typically handled by standard `Text` or `String` functions.         |
| **Error Checking**  | Compile-time checks for data schema mismatches (after static type generation). Runtime checks for dynamic operations. | Strong compile-time checks for data schema and field access.        |
| **Performance**     | In-memory processing.                                      | In-memory and streaming interfaces for large datasets.              |
| **Learning Curve**  | Moderate (familiar to Pandas users, but with Haskell's type system). | Steeper (due to Template Haskell, lenses, and functional programming paradigms). |
| **Ecosystem Integration** | Standard Haskell libraries.                               | Strong integration with `lens`, `foldl`, and `beam` (for databases). |

## Summary:

Both `sara` (with its new static typing capabilities) and `Frames` offer robust solutions for data manipulation in Haskell, emphasizing type safety.

*   **`sara`** aims to provide a more familiar experience for users coming from Python's Pandas, offering a similar API style while leveraging Haskell's type system to catch errors earlier. Its built-in time series, missing data, and extensive statistical functions make it a comprehensive tool for data analysis.

*   **`Frames`** excels in its deep integration with Haskell's type system and functional programming idioms (like lenses and `foldl`), providing extremely strong compile-time guarantees and efficient handling of large datasets through streaming. While it might have a steeper initial learning curve, its type safety and performance benefits are significant for complex data pipelines.

The choice between `sara` and `Frames` largely depends on user preference for API style, the importance of deep functional programming integration, and the specific data processing needs (e.g., built-in time series functionality in `sara` vs. `Frames`'s streaming capabilities).
